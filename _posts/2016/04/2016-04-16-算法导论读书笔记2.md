---
toc:
  sidebar: true
giscus_comments: true
layout: post
title: "算法导论读书笔记(2)"
date: "2016-04-16"
categories: 
  - "algorithms"
---

### I.渐进符号(此部分借鉴自[Lazy pig](http://www.cnblogs.com/sungoshawk/p/3619780.html#sec-1))

当输入规模大到使运行时间只和增长的量级有关时，就是在研究算法的 **渐近** 效率。就是说，从极限角度看，我们只关心算法运行时间如何随着输入规模的无限增长而增长。

五种渐进符号 Ο   Θ  Ω  ο  ω

对任何一个函数 _f_ ( _n_ )，若存在正常数 _c1_ ， _c2_ ，使当 _n_ 充分大时， _f_ ( _n_ )能被夹在 _c1 g_ ( _n_ )和 _c2 g_ ( _n_ )之间，则 _f_ ( _n_ )属于集合 _Θ_ ( _g_ ( _n_ ))。可以写成“ _f_ ( _n_ ) ∈ _Θ_ ( _g_ ( _n_ ))”表示 _f_ ( _n_ )是 _Θ_ ( _g_ ( _n_ ))的元素。不过，通常写成“ _f_ ( _n_ ) = _Θ_ (_g_ ( _n_ ))”来表示相同的意思。![232232556626677](https://zhengliangliang.files.wordpress.com/2016/04/232232556626677.png)

上图(a)给出了函数 _f_ ( _n_ )和 _g_ ( _n_ )的直观图示，其中 _f_ ( _n_ ) = _Θ_ ( _g_ ( _n_ ))。对所有位于 _n0_ 右边的 _n_ 值， _f_ ( _n_ )的值落在 _c1g_ ( _n_ )和 _c2 g_ ( _n_ )之间。换句话说，对所有的 _n_ >= _n0_ ， _f_ ( _n_ )在一个常数因子范围内与 _g_ ( _n_ )相等。我们说 _g_ ( _n_ )是 _f_( _n_ )的一个 **渐近确界** 。

![](https://zhengliangliang.files.wordpress.com/2016/04/232232385069118.png)

_Θ_ ( _g_ ( _n_ ))的定义要求每个成员 _f_ ( _n_ ) ∈ _Θ_ ( _g_ ( _n_ ))都是 **渐近非负** ，就是说当 _n_ 足够大时 _f_ ( _n_ )是非负值。这就要求函数_g_ ( _n_ )本身也是渐近非负的，否则集合 _Θ_ ( _g_ ( _n_ ))就是空集。

_Θ_ 记号的效果相当于舍弃了低阶项和忽略了最高阶项的系数。

* * *

 

_Θ_ 记号渐近地给出了一个函数的上界和下界。当只有 **渐近上界** 时，使用 _O_ 记号。对一个函数 _g_ ( _n_ )，用 _O_ ( _g_ ( _n_ ))表示一个函数集合：

![232233133815364](https://zhengliangliang.files.wordpress.com/2016/04/232233133815364.png)

上图(b)说明了 _O_ 记号的直观意义。对所有位于 _n0_ 右边的 _n_ 值，函数 _f_ ( _n_ )的值在 _g_ ( _n_ )下。

* * *

_Ω_ 记号给出了函数的渐近下界。给定一个函数 _g_ ( _n_ )，用 _Ω_ ( _g_ ( _n_ ))表示一个函数集合：

![](https://zhengliangliang.files.wordpress.com/2016/04/232233433183984.png)

上图(c)说明了 _Ω_ 记号的直观意义。对所有在 _n0_ 右边的 _n_ 值，函数 _f_ ( _n_ )的数值等于或大于 _c g_ ( _n_ )。

* * *

_O_ 记号提供的渐近上界**可能是也可能不是渐近紧确**的。这里用 _o_ 记号表示非渐近紧确的上界。 _o_ ( _g_ ( _n_ ))的形式定义为集合：

![](https://zhengliangliang.files.wordpress.com/2016/04/232233528966792.png)

_O_ 记号与 _o_ 记号的主要区别在于对 _f_ ( _n_ ) = _O_ ( _g_ ( _n_ ))，界0 <= _f_ ( _n_ ) <= _c g_ ( _n_ )对某个常数 _c_ > 0成立；但对 _f_ ( _n_ ) = _o_ ( _g_ ( _n_ ))，界0 <= _f_ ( _n_ ) <= _c g_ ( _n_ )对所有常数 _c_ > 0都成立。即

![](https://zhengliangliang.files.wordpress.com/2016/04/232234060062054.png)

* * *

我们用 _ω_ 记号来表示非渐近紧确的下界。 _ω_ ( _g_ ( _n_ ))的形式定义为集合：

![](https://zhengliangliang.files.wordpress.com/2016/04/232234135216991.png)

关系 _f_ ( _n_ ) = _ω_ ( _g_ ( _n_ ))意味着

![](https://zhengliangliang.files.wordpress.com/2016/04/232234214279642.png)

如果这个极限存在。也就是说当 _n_ 趋于无穷时， _f_ ( _n_ )相对 _g_ ( _n_ )来说变得任意大了。

 

附：函数间的比较

**设 _f_ ( _n_ )和 _g_ ( _n_ )是渐近正值函数。**

**传递性：** _f_ ( _n_ ) = _Θ_ ( _g_ ( _n_ ))和 _g_ ( _n_ ) = _Θ_ ( _h_ ( _n_ )) 蕴含 _f_ ( _n_ ) = _Θ_ ( _h_ ( _n_ )) _f_ ( _n_ ) = _O_ ( _g_ ( _n_ ))和 _g_ ( _n_ ) = _O_ ( _h_ ( _n_ )) 蕴含 _f_ ( _n_ ) = _O_ ( _h_ ( _n_ )) _f_ ( _n_ ) = _Ω_ ( _g_ ( _n_ ))和 _g_ ( _n_ ) = _Ω_ ( _h_ ( _n_ )) 蕴含 _f_ ( _n_ ) = _Ω_ ( _h_ ( _n_ )) _f_ ( _n_ ) = _o_ ( _g_ ( _n_ ))和 _g_ ( _n_ ) = _o_ ( _h_ ( _n_ )) 蕴含 _f_ ( _n_ ) = _o_ ( _h_ ( _n_ )) _f_ ( _n_ ) = _ω_ ( _g_ ( _n_ ))和 _g_ ( _n_ ) = _ω_ ( _h_ ( _n_ )) 蕴含 _f_ ( _n_ ) = _ω_ ( _h_ ( _n_ ))

**自反性：** _f_ ( _n_ ) = _Θ_ ( _f_ ( _n_ )) _f_ ( _n_ ) = _O_ ( _f_ ( _n_ )) _f_ ( _n_ ) = _Ω_ ( _f_ ( _n_ ))

**对称性：** _f_ ( _n_ ) = _Θ_ ( _g_ ( _n_ ))当且仅当 _g_ ( _n_ ) = _Θ_ ( _f_ ( _n_ ))

**转置对称性：** _f_ ( _n_ ) = _O_ ( _g_ ( _n_ ))当且仅当 _g_ ( _n_ ) = _Ω_ ( _f_ ( _n_ )) _f_ ( _n_ ) = _o_ ( _g_ ( _n_ ))当且仅当 _g_ ( _n_ ) = _ω_ ( _f_ ( _n_ ))

 

### II. **主方法和递归树方法**

#### Master Method

- T(n) = aT(n/b) +h(n)
- a>=1; b>1;h(n):不参与递归的复杂度函数

实际用法 判断n^log b (a)与h(n)的大小关系

定理一：>Θ(h(n))  : 复杂度       Θ(n^(log b (a)))

定理二：= Θ(h(n)) : 复杂度       Θ(h(n)*lg(n))

定理三：<Θ(h(n))  : 复杂度       Θ(h(n))

例子:

(1). T(n) = 9T(n/3) + n

a = 9   b = 3     n^log b (a) = n^log3(9) = n^2

n^2 > n           利用定理1   Θ(n^2)

(2) T(n) = T(2n/3)  + 1

a = 1    b =  3/2    n^log b (a) = n^log 3/2 (1) = 1

1 = h(n)             利用定理2   Θ(1*lgn)

(3) T(n) = 3T(n/4)  + nlgn

a = 3    b =  4    n^log b (a) = n^log 4 (3)

n^log 4 (3) < h(n)     利用定理3   Θ(nlgn)

#### Recursion Tree Method

主要是把递归式转换成树的形式，则利用树的数学概念和特性可以知道树高和叶子结点个数，从而可以求解出算法的复杂度。当然这种方法更合适你去验证自己的结论，因为是严格的证明过程。

 

谷歌上面找了一个代换法来解决递归树的证明PPT，直接搬运过来翻译。（借鉴自：[MSC:introduction to Algorithm](http://homepages.math.uic.edu/~jan/mcs360/recursion_tree_method.pdf)）

![2016-04-16_152808](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_152808.png)

代换法解决递归树包括2步

①  猜测解决的规模形式大小

②用数学归纳法找到常量并证明方法可用

- 1 将递归放进树里面

假设递归式:  T(n) = 3T(n/4) + cn^2    [c是常数]

递归式里面  如 T(n) = aT(n/b) + h(n)

a是分解后的子规模 b是把和h(n)的规模的式子分解为原来的1/b

![2016-04-16_153421](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_153421.png)

继续递归下去

T（n/4） = 3T(n/16) + c(n/4)^2

 

![2016-04-16_153553.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_153553.png)

接下去递归

![2016-04-16_153639](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_153639.png)

- 计算每一层的cost

![2016-04-16_153738.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_153738.png)

计算每一层的cost之和

![2016-04-16_153917.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_153917.png)

如果要约分分母，如果有 n = 16的话

或者 这棵树高度至少为2   如果  n>=16 = 4^2

对于  n = 4^k   k = log4(n)   可以得

![2016-04-16_154306.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_154306.png)

 

 

如果你个有穷和为

![2016-04-16_154446.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_154446.png)

如果要找到一般式 归纳 作差法：

![2016-04-16_154534.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_154534.png)

求出Sn的一般式子

![2016-04-16_154709](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_154709.png)

对于刚刚的式子 r的位置应该是 3/16.所以可以变换成

![2016-04-16_154823.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_154823.png)

对于T（n）<=dn^2的式子 有 上式

不考虑log4(n) 则有

![2016-04-16_155107.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_155107.png)

 

尝试使用递归树

![2016-04-16_155206.png](https://zhengliangliang.files.wordpress.com/2016/04/2016-04-16_155206.png)

第二个算法导论的笔记就写到这吧！
